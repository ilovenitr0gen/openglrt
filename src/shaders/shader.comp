R"(
#version 460 core

layout (local_size_x = 1, local_size_y = 1, local_size_z = 1) in;

layout(rgba32f, binding = 0) uniform image2D imageOut;

struct Material {
	vec3 color;
};

struct Sphere {
	vec3 position;
	float radiusSquared;
	vec3 color;
	bool lightSource;
};

struct Ray {
	vec3 origin;
	vec3 direction;
};

struct SphereTestResult {
	bool intersects;
	float dist;
	vec3 position;
	vec3 normal;
	vec3 color;
};

const Sphere spheres[] = {
	Sphere(vec3(15,0,0), 100, vec3(0,1,0), false),
	Sphere(vec3(0,20,0), 64, vec3(0,0,1), false),
	Sphere(vec3(-50,-40,10), 3000, vec3(1,1,1), true),
	Sphere(vec3(100, 150, 0), 2000, vec3(1,0,0), false),
	Sphere(vec3(0, -10000, 0), 10000000, vec3(1, 0.7, 0), false)
};

const uint maxRayCount = 4;

uniform vec3 cameraPos;
uniform vec3 q_x;
uniform vec3 q_y;
uniform vec3 startPixel;

//gl_NumWorkGroups is equal to the resolution of the image to be rendered  
//gl_GlobalInvocationID is equal to the position of the current pixel as an integer

SphereTestResult testSphere(Ray ray, Sphere sphere) { //returns the point of nearest intersection
	ray.origin -= sphere.position;// this simplifies the intersection equation
	float originDotDirection = dot(ray.origin, ray.direction);
	float discriminant = pow(originDotDirection, 2) - (dot(ray.origin, ray.origin) - sphere.radiusSquared);

	SphereTestResult result = SphereTestResult(false, 0.0f, vec3(0.0f), vec3(0.0f), vec3(0.0f));

	if (discriminant == 0 && (-originDotDirection) > 0) {
		result.intersects = true;
		result.dist = -originDotDirection;
	} else if (discriminant > 0) {
		result.intersects = true;
		float discriminantRoot = sqrt(discriminant);
		float d_1 = -originDotDirection + discriminantRoot;
		float d_2 = -originDotDirection - discriminantRoot;
		if (d_1 > 0 && d_2 > 0) {
			result.dist = min(d_1, d_2);
		} else if (d_1 > 0) {
			result.dist = d_1;
		} else if (d_2 > 0) {
			result.dist = d_2;
		} else { result.intersects = false; }
	}
	
	if (result.intersects) {
		result.position = ray.origin + ray.direction * result.dist + sphere.position; 
		result.normal = normalize(result.position - sphere.position);
		result.position += result.normal * 1.00001;//the extra multiplier is so it doesnt intersect with itself on the next test
		result.color = sphere.color;
	}

	return result;
}

void main() {

	Ray ray = Ray(cameraPos, normalize(startPixel + q_x * (gl_GlobalInvocationID.x) + q_y * (gl_GlobalInvocationID.y))); // indexed from top-left

	ivec2 pixelCoord = ivec2(gl_GlobalInvocationID.xy);

	vec3 color = vec3(0.0f); //color of a ray which misses
	
	uint remainingRays = maxRayCount;

	vec3 lastColor = vec3(0.0f);

	while (remainingRays > 0) {
		SphereTestResult closestResult = SphereTestResult(false, pow(2,31), vec3(0.0f), vec3(0.0f), vec3(0.0f));

		bool isLightSource = false;
		for (int i = 0; i < spheres.length(); i++) {
			SphereTestResult result = testSphere(ray, spheres[i]);
			if (result.intersects && result.dist < closestResult.dist) {
				closestResult = result;
				isLightSource = spheres[i].lightSource;
			}
		}
		
		if (closestResult.intersects) {
			lastColor = closestResult.color;
		}

		ray.direction = reflect(ray.direction, closestResult.normal);
		ray.origin = closestResult.position;

		--remainingRays;


		if (isLightSource) { remainingRays = 0; color = closestResult.color;}
		//else if (remainingRays == 0) {color = vec3(0.0f);}
		
		else if (!closestResult.intersects || remainingRays == 0) { 
			color = lastColor * (remainingRays+1)/maxRayCount;
			remainingRays = 0; 
		}
	}

	
	

    imageStore(imageOut, pixelCoord, vec4(color, 1.0f));
}
)"
