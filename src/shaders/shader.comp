R"(
#version 460 core

layout (local_size_x = 1, local_size_y = 1, local_size_z = 1) in;

layout(rgba32f, binding = 0) uniform image2D imageOut;

struct Material {
	vec3 color;
};

struct Sphere {
	vec3 position;
	float radiusSquared;
	vec3 color;
	bool lightSource;
};

struct Ray {
	vec3 origin;
	vec3 direction;
};

struct SphereTestResult {
	bool intersects;
	float dist;
	vec3 position;
	vec3 normal;
	vec3 color;
};

const Sphere spheres[] = {
	Sphere(vec3(15,0,0), 100, vec3(0,0.9,0), false),
	Sphere(vec3(0,20,0), 64, vec3(0,0,0.9), false),
	Sphere(vec3(-50,-40,10), 3000, vec3(1,1,1), true),
	Sphere(vec3(100, 150, 0), 2000, vec3(0.9,0,0), false),
	Sphere(vec3(0, -10000, 0), 10000000, vec3(0.9, 0.7, 0), false)
};

const uint maxDepth = 8;
const uint samplesPerPixel = 64;

uniform vec3 cameraPos;
uniform vec3 q_x;
uniform vec3 q_y;
uniform vec3 startPixel;

//gl_NumWorkGroups is equal to the resolution of the image to be rendered  
//gl_GlobalInvocationID is equal to the position of the current pixel as an integer



// www.pcg-random.org and www.shadertoy.com/view/XlGcRh
uint nextRandom(inout uint randomState) {
	randomState = randomState * 747796405 + 2891336453;
	uint result = ((randomState >> ((randomState >> 28) + 4)) ^ randomState) * 277803737;
	result = (result >> 22) ^ result;
	return result;
}

// scaled value (0 to 1)
float randomFloatNormalized(inout uint randomState) {
	return nextRandom(randomState) / 4294967295.0; // 2^32 - 1
}


// https://stackoverflow.com/a/6178290
float randomFloatNormalDistribution(inout uint randomState) {
	float theta = 2 * 3.1415926 * randomFloatNormalized(randomState);
	float rho = sqrt(-2 * log(randomFloatNormalized(randomState)));
	return rho * cos(theta);
}

vec3 randomDirection(inout uint randomState) {
	return normalize(vec3(
				randomFloatNormalDistribution(randomState),
				randomFloatNormalDistribution(randomState),
				randomFloatNormalDistribution(randomState)));
}

vec3 randomHemisphereDirection(inout uint randomState, vec3 normal) {
	vec3 dir = randomDirection(randomState);
	return dir * sign(dot(normal, dir));
}


//vec3 diffuseReflect(inout uint state, 

SphereTestResult testSphere(Ray ray, Sphere sphere) { //returns the point of nearest intersection
	ray.origin -= sphere.position;// this simplifies the intersection equation
	float originDotDirection = dot(ray.origin, ray.direction);
	float discriminant = pow(originDotDirection, 2) - (dot(ray.origin, ray.origin) - sphere.radiusSquared);

	SphereTestResult result = SphereTestResult(false, 0.0f, vec3(0.0f), vec3(0.0f), vec3(0.0f));

	if (discriminant >= 0) {
		float dist = -originDotDirection - sqrt(discriminant); //the second solution can be ignored as it is always further away from the ray origin, so would be behind the first solution
		if (dist >= 0) {
			result.intersects = true;
			result.dist = dist;
		}
	}
	
	if (result.intersects) {
		result.position = ray.origin + ray.direction * result.dist + sphere.position; 
		result.normal = normalize(result.position - sphere.position);
		result.position += result.normal * 1.00001;//the extra multiplier is so it doesnt intersect with itself on the next test
		result.color = sphere.color;
	}

	return result;
}

vec3 traceRay(inout uint randomState, Ray ray) {
	uint remainingRays = maxDepth;

	vec3 color = vec3(1.0f); //color of a ray which misses
	
	while (remainingRays > 0) {
		SphereTestResult closestResult = SphereTestResult(false, pow(2,31), vec3(0.0f), vec3(0.0f), vec3(0.0f));

		bool isLightSource = false;
		for (int i = 0; i < spheres.length(); ++i) {
			SphereTestResult result = testSphere(ray, spheres[i]);
			if (result.intersects && result.dist < closestResult.dist) {
				closestResult = result;
				isLightSource = spheres[i].lightSource;
			}
		}

		//for (int i = 0; i < 30; i++) {
		//	Sphere sphere = Sphere(vec3(15 + i * 2,0,0), 1, vec3(0.7,0,1-(float(i)/30.0)), false);
		//	SphereTestResult result = testSphere(ray, sphere);
		//	if (result.intersects && result.dist < closestResult.dist) {
		//		closestResult = result;
		//		isLightSource = sphere.lightSource;
		//	}
		//}
		
		if (closestResult.intersects) {
			color *= closestResult.color;
		}

		--remainingRays;

		if (isLightSource) { break; }
		else if (!closestResult.intersects || remainingRays == 0) { 
			color = vec3(0.0f);
			break;
		}
		
		//ray.direction = reflect(ray.direction, closestResult.normal);
		ray.direction = randomHemisphereDirection(randomState, closestResult.normal);
		ray.origin = closestResult.position;
	}

	return color;
};

void main() {

	Ray ray = Ray(cameraPos, normalize(startPixel + q_x * (gl_GlobalInvocationID.x) + q_y * (gl_GlobalInvocationID.y))); // indexed from top-left

	vec3 color = vec3(0.0f);

	for (int i = 0; i < samplesPerPixel; ++i) {
		uint randomState = gl_GlobalInvocationID.x + gl_NumWorkGroups.x * gl_GlobalInvocationID.y + i * 8329023; //random number of no significance
		color += traceRay(randomState, ray);
	}
	
	color /= samplesPerPixel;

	ivec2 pixelCoord = ivec2(gl_GlobalInvocationID.xy);
    imageStore(imageOut, pixelCoord, vec4(color, 1.0f));
}
)"
