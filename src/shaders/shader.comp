R"(
#version 460 core

layout (local_size_x = 1, local_size_y = 1, local_size_z = 1) in;

layout(rgba32f, binding = 0) uniform image2D imageOut;

struct Material {
	vec3 color;
};

struct Sphere {
	vec3 position;
	float radiusSquared;
	vec3 color;
	bool lightSource;
};

struct Ray {
	vec3 origin;
	vec3 direction;
};

struct SphereTestResult {
	bool intersects;
	float dist;
	vec3 position;
	vec3 normal;
};

const Sphere spheres[] = {
	Sphere(vec3(15,0,0), 100, vec3(0,0.9,0), false),
	Sphere(vec3(0,20,0), 64, vec3(0,0,0.9), false),
	Sphere(vec3(-50,-40,10), 3000, vec3(1,1,1), true),
	//Sphere(vec3(100, 150, 0), 2000, vec3(0.9,0,0), false),
	//Sphere(vec3(0, -10000, 0), 10000000, vec3(0.9, 0.7, 0), false)
};

const uint maxDepth = 8;
const uint samplesPerPixel = 16;

uniform float deltaTime;

uniform int frameIndex;

uniform vec3 cameraPos;
uniform vec3 q_x;
uniform vec3 q_y;
uniform vec3 startPixel;

//gl_NumWorkGroups is equal to the resolution of the image to be rendered  
//gl_WorkGroupID is equal to the position of the current pixel as an integer



// www.pcg-random.org and www.shadertoy.com/view/XlGcRh
uint nextRandom(inout uint randomState) {
	randomState = randomState * 747796405 + 2891336453;
	uint result = ((randomState >> ((randomState >> 28) + 4)) ^ randomState) * 277803737;
	result = (result >> 22) ^ result;
	return result;
}

// scaled value (0 to 1)
float randomFloatNormalized(inout uint randomState) {
	return nextRandom(randomState) / 4294967295.0; // 2^32 - 1
}


// https://stackoverflow.com/a/6178290
float randomFloatNormalDistribution(inout uint randomState) {
	float theta = 2 * 3.1415926 * randomFloatNormalized(randomState);
	float rho = sqrt(-2 * log(randomFloatNormalized(randomState)));
	return rho * cos(theta);
}

vec3 randomDirection(inout uint randomState) {
	return normalize(vec3(
				randomFloatNormalDistribution(randomState),
				randomFloatNormalDistribution(randomState),
				randomFloatNormalDistribution(randomState)));
}

vec3 randomHemisphereDirection(inout uint randomState, vec3 normal) {
	vec3 dir = randomDirection(randomState);
	return dir * sign(dot(normal, dir));
}




SphereTestResult testSphere(in Ray ray, in vec3 spherePosition, in float radiusSquared) { //returns the point of nearest intersection
	vec3 offsetRayOrigin = ray.origin - spherePosition;// this simplifies the intersection equation
	float originDotDirection = dot(offsetRayOrigin, ray.direction);
	float discriminant = originDotDirection * originDotDirection - (dot(offsetRayOrigin, offsetRayOrigin) - radiusSquared);

	SphereTestResult result;

	result.intersects = false;

	if (discriminant >= 0) {
		float dist = -originDotDirection - sqrt(discriminant); //the second solution can be ignored as it is always further away from the ray origin, so would be behind the first solution
		if (dist >= 0) {
			result.intersects = true;
			result.dist = dist;
			result.position = ray.origin + ray.direction * result.dist; 
			result.normal = normalize(result.position - spherePosition);
			result.position += result.normal * 1.01;//the extra multiplier is so it doesnt intersect with itself on the next test
		}
	}
	
	return result;
}

vec3 traceRay(inout uint randomState, Ray ray) {
	uint remainingRays = maxDepth;

	vec3 color = vec3(1.0f); //color of a ray which misses
	
	while (remainingRays > 0) {
		SphereTestResult closestResult = SphereTestResult(false, pow(2,31), vec3(0.0f), vec3(0.0f));
		
		int closestSphere = -1; //index of the sphere. -1 indicates no intersection

		for (int i = 0; i < spheres.length(); ++i) {
			SphereTestResult result = testSphere(ray, spheres[i].position, spheres[i].radiusSquared);
			if (result.intersects && result.dist < closestResult.dist) {
				closestResult = result;
				closestSphere = i;
			}
		}

		//for (int i = 0; i < 30; i++) {
		//	Sphere sphere = Sphere(vec3(15 + i * 2,0,0), 1, vec3(0.7,0,1-(float(i)/30.0)), false);
		//	SphereTestResult result = testSphere(ray, sphere);
		//	if (result.intersects && result.dist < closestResult.dist) {
		//		closestResult = result;
		//		isLightSource = sphere.lightSource;
		//	}
		//}
		
		if (closestSphere != -1) {
			color *= spheres[closestSphere].color;
			if (spheres[closestSphere].lightSource) {
				break;
			}
		}

		--remainingRays;

		if (closestSphere == -1 || remainingRays == 0) { 
			color = vec3(0.0f);
			break;
		}
		
		//ray.direction = reflect(ray.direction, closestResult.normal);
		ray.direction = randomHemisphereDirection(randomState, closestResult.normal);
		ray.origin = closestResult.position;
	}

	return color;
};

void main() {

	Ray ray = Ray(cameraPos, normalize(startPixel + q_x * (gl_WorkGroupID.x) + q_y * (gl_WorkGroupID.y))); // indexed from top-left

	vec3 color = vec3(0.0f);

	for (int i = 0; i < samplesPerPixel; ++i) {// TODO SPLIT INTO DIFFERENT WORK UNIT THINGS
		uint randomState = gl_WorkGroupID.x + gl_NumWorkGroups.x * gl_WorkGroupID.y + i * 832349023 + frameIndex * 5324071/*random number of no significance*/; 
		color += traceRay(randomState, ray);
	}
	
	color /= samplesPerPixel;

	ivec2 pixelCoord = ivec2(gl_WorkGroupID.xy);
	vec4 oldColor = imageLoad(imageOut, pixelCoord);
	vec3 newColor = ( oldColor.xyz * (frameIndex) + color ) / (frameIndex+1);
    imageStore(imageOut, pixelCoord, vec4(newColor, 1.0f));
}
)"
